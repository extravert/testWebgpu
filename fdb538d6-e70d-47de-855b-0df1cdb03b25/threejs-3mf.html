<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js 3MF Viewer</title>
    <style>
      body {
        margin: 0;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      #toolbar {
        padding: 8px 12px;
        background: #111;
        color: #ddd;
        display: flex;
        gap: 12px;
        align-items: center;
      }
      #viewer {
        flex: 1 1 auto;
        position: relative;
      }
      canvas { display: block; width: 100%; height: 100%; }
      input[type="file"] { color: #ddd; }
    </style>
  </head>
  <body>
    <div id="toolbar">
      <input id="file" type="file" accept=".3mf,.stl,.obj" />
      <span>选择 3D 文件以加载 (.3mf, .stl, .obj)</span>
      <span id="status" style="margin-left:12px;color:#9aa0a6;"></span>
    </div>
    <div id="viewer"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.165.0/build/three.module.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
      import { OrbitControls } from 'https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js';
      import { ThreeMFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/3MFLoader.js';
      import { STLLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/STLLoader.js';
      import { OBJLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/OBJLoader.js';

      const container = document.getElementById('viewer');

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(container.clientWidth, container.clientHeight, false);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202124);

      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
      camera.position.set(3, 2, 6);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // 灯光
      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      hemi.position.set(0, 1, 0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(5, 10, 7);
      scene.add(dir);

      // 可视化辅助
      const axes = new THREE.AxesHelper(1.5);
      scene.add(axes);
      // scene.add(new THREE.GridHelper(10, 10));

      function resize() {
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(w, h, false);
        camera.aspect = Math.max(1, w) / Math.max(1, h);
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resize);
      resize();

      // 载入 3D 文件
      const fileInput = document.getElementById('file');
      const statusEl = document.getElementById('status');
      const threeMFLoader = new ThreeMFLoader();
      const stlLoader = new STLLoader();
      const objLoader = new OBJLoader();
      
      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;

        console.time('[3D] parse');
        statusEl.textContent = `正在加载: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`;
        const arrayBuffer = await file.arrayBuffer();
        let object = null;
        
        try {
          // 优先尝试 3MF
          if (file.name.toLowerCase().endsWith('.3mf')) {
            try {
              object = threeMFLoader.parse(arrayBuffer);
              console.log('[3MF] parsed object:', object);
            } catch (threeMFError) {
              console.warn('[3MF] 标准解析失败，尝试备用方法:', threeMFError);
              // 尝试作为二进制 STL 解析（某些 3MF 可能包含 STL 数据）
              try {
                const geometry = stlLoader.parse(arrayBuffer);
                const material = new THREE.MeshStandardMaterial({ 
                  color: 0x66cc66, 
                  roughness: 0.8, 
                  metalness: 0.0,
                  side: THREE.DoubleSide 
                });
                object = new THREE.Mesh(geometry, material);
                console.log('[3MF->STL] 备用解析成功:', object);
              } catch (stlError) {
                throw new Error(`3MF 解析失败: ${threeMFError.message}。请尝试转换为 STL 或 OBJ 格式。`);
              }
            }
          } else if (file.name.toLowerCase().endsWith('.stl')) {
            const geometry = stlLoader.parse(arrayBuffer);
            console.log('[STL] parsed geometry:', geometry);
            // STL 解析返回的是 BufferGeometry，需要包装成 Mesh
            const material = new THREE.MeshStandardMaterial({ 
              color: 0x66cc66, 
              roughness: 0.8, 
              metalness: 0.0,
              side: THREE.DoubleSide 
            });
            object = new THREE.Mesh(geometry, material);
            console.log('[STL] wrapped in mesh:', object);
          } else if (file.name.toLowerCase().endsWith('.obj')) {
            object = objLoader.parse(new TextDecoder().decode(arrayBuffer));
            console.log('[OBJ] parsed object:', object);
          } else {
            throw new Error('不支持的文件格式，请选择 .3mf, .stl, 或 .obj 文件');
          }

          // 清理旧模型
          const old = scene.getObjectByName('MODEL_ROOT');
          if (old) {
            scene.remove(old);
          }

          // 归一化并居中
          const root = new THREE.Group();
          root.name = 'MODEL_ROOT';
          
          // 确保 object 是有效的 Object3D
          if (object && object.isObject3D) {
            root.add(object);
          } else if (object && object.isBufferGeometry) {
            // 如果返回的是 BufferGeometry，包装成 Mesh
            const material = new THREE.MeshStandardMaterial({ 
              color: 0x66cc66, 
              roughness: 0.8, 
              metalness: 0.0,
              side: THREE.DoubleSide 
            });
            const mesh = new THREE.Mesh(object, material);
            root.add(mesh);
            console.log('[3D] wrapped geometry in mesh');
          } else {
            throw new Error('无法识别的对象类型');
          }
          // 规范化材质与可见性，避免透明/背面剔除导致不可见
          root.traverse((node) => {
            if (node.isMesh) {
              const mat = node.material;
              if (!mat) {
                node.material = new THREE.MeshStandardMaterial({ color: 0x66cc66, roughness: 0.8, metalness: 0.0, side: THREE.DoubleSide });
              } else {
                mat.side = THREE.DoubleSide;
                if (mat.transparent && mat.opacity === 0) {
                  mat.transparent = false;
                  mat.opacity = 1.0;
                }
              }
              node.castShadow = true;
              node.receiveShadow = true;
              node.frustumCulled = false;
            }
          });
          scene.add(root);

          // 计算包围盒并居中/缩放到合适大小
          const bbox = new THREE.Box3().setFromObject(root);
          const size = new THREE.Vector3();
          const center = new THREE.Vector3();
          bbox.getSize(size);
          bbox.getCenter(center);
          console.log('[3D] bbox size:', size, 'center:', center);
          
          // 强制居中到原点
          root.position.sub(center);
          console.log('[3D] moved to center, new position:', root.position);

          const maxDim = Math.max(size.x, size.y, size.z) || 1;
          console.log('[3D] maxDim:', maxDim);
          
          // 改进缩放逻辑：确保模型在合理范围内可见
          let scale = 1.0;
          if (maxDim === 0 || maxDim < 0.001) {
            scale = 10.0; // 空或极小模型
            console.log('[3D] 模型太小或为空，使用默认缩放');
          } else if (maxDim < 0.1) {
            scale = 20.0; // 极小模型放大20倍
          } else if (maxDim < 1.0) {
            scale = 2.0 / maxDim; // 小模型正常缩放
          } else if (maxDim < 10.0) {
            scale = 1.0; // 中等模型保持原大小
          } else {
            scale = 2.0 / maxDim; // 大模型缩小
          }
          
          root.scale.setScalar(scale);
          console.log('[3D] applied scale:', scale);
          
          // 重新计算最终包围盒
          const finalBbox = new THREE.Box3().setFromObject(root);
          const finalSize = new THREE.Vector3();
          finalBbox.getSize(finalSize);
          console.log('[3D] final bbox size:', finalSize);

          // 显示包围盒辅助以确认位置与大小
          const oldHelper = scene.getObjectByName('MODEL_BBOX_HELPER');
          if (oldHelper) scene.remove(oldHelper);
          const helper = new THREE.Box3Helper(new THREE.Box3().setFromObject(root), 0x00ffff);
          helper.name = 'MODEL_BBOX_HELPER';
          scene.add(helper);

          // 将相机摆到合适位置，确保能看到模型
          const finalCenter = new THREE.Vector3();
          finalBbox.getCenter(finalCenter);
          console.log('[3D] final center:', finalCenter);
          
          // 相机距离基于模型大小调整
          const distance = Math.max(finalSize.length() * 2, 2);
          camera.position.set(distance, distance * 0.5, distance);
          controls.target.copy(finalCenter);
          controls.update();
          console.log('[3D] camera position:', camera.position, 'target:', controls.target);

          statusEl.textContent = `加载完成: ${file.name}`;
          console.timeEnd('[3D] parse');
        } catch (err) {
          console.error('3D 文件加载失败:', err);
          statusEl.textContent = `加载失败: ${err?.message || err}`;
          // 不弹窗，只在状态栏显示错误
        }
      });

      function tick(t) {
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    </script>
  </body>
  </html>


