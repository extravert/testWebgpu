<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rotating Cube with WebGL</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="glCanvas" width="640" height="480"></canvas>
    <script>
      // 顶点着色器源码
      const vertexShaderSource = `
        attribute vec4 aVertexPosition; // 输入顶点位置
        uniform mat4 uModelViewMatrix;  // 模型视图矩阵
        uniform mat4 uProjectionMatrix; // 投影矩阵

        void main(void) {
            // 计算顶点位置
            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        }
    `;

      // 片段着色器源码
      const fragmentShaderSource = `
        void main(void) {
            gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);  // 输出绿色
        }
    `;

      // 初始化着色器程序
      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource); // 创建顶点着色器
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource); // 创建片段着色器

        const shaderProgram = gl.createProgram(); // 创建着色器程序
        gl.attachShader(shaderProgram, vertexShader); // 将顶点着色器附加到程序
        gl.attachShader(shaderProgram, fragmentShader); // 将片段着色器附加到程序
        gl.linkProgram(shaderProgram); // 链接程序

        // 检查链接是否成功
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          console.error(
            "Unable to initialize the shader program:",
            gl.getProgramInfoLog(shaderProgram)
          );
          return null;
        }
        return shaderProgram;
      }

      // 加载并编译着色器
      function loadShader(gl, type, source) {
        const shader = gl.createShader(type); // 创建着色器对象
        gl.shaderSource(shader, source); // 提供着色器源码
        gl.compileShader(shader); // 编译着色器

        // 检查编译是否成功
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(
            "An error occurred compiling the shaders:",
            gl.getShaderInfoLog(shader)
          );
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      // 初始化立方体的顶点和索引缓冲区
      function initBuffers(gl) {
        // 创建并绑定顶点缓冲区对象
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        // 定义立方体的顶点坐标
        const vertices = new Float32Array([
          // Front face
          -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0,

          // Back face
          -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0,

          // Top face
          -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0,

          // Bottom face
          -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0,

          // Right face
          1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0,

          // Left face
          -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); // 将顶点数据传递给缓冲区

        // 创建并绑定索引缓冲区对象
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        // 定义立方体的索引数据，表示每个面由哪些顶点组成
        const indices = new Uint16Array([
          0,
          1,
          2,
          0,
          2,
          3, // Front face
          4,
          5,
          6,
          4,
          6,
          7, // Back face
          8,
          9,
          10,
          8,
          10,
          11, // Top face
          12,
          13,
          14,
          12,
          14,
          15, // Bottom face
          16,
          17,
          18,
          16,
          18,
          19, // Right face
          20,
          21,
          22,
          20,
          22,
          23, // Left face
        ]);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); // 将索引数据传递给缓冲区

        return {
          position: positionBuffer,
          indices: indexBuffer,
        };
      }

      // 全局变量，用于跟踪上一次动画帧的时间
      let then = 0;

      ////  即时渲染 
      // 绘制场景函数 每帧都要重复设置状态和绘制
      function drawScene(gl, programInfo, buffers, rotation) {
        // 清除画布
        gl.clearColor(0.0, 0.0, 0.0, 1.0); // 黑色背景
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 清除颜色缓冲区和深度缓冲区
        gl.enable(gl.DEPTH_TEST); // 启用深度测试

        // 设置顶点属性
        const numComponents = 3; // 每个顶点由三个分量（x, y, z）组成
        const type = gl.FLOAT; // 数据类型为32位浮点数
        const normalize = false; // 不规范化数据
        const stride = 0; // 每个顶点数据间隔为0，表示紧密排列
        const offset = 0; // 从缓冲区的起始位置读取数据

        // 每次都要重新绑定和设置
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(
          programInfo.attribLocations.vertexPosition,
          numComponents,
          type,
          normalize,
          stride,
          offset
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

        gl.useProgram(programInfo.program); // 使用着色器程序

        // 创建并设置模型视图矩阵
        const modelViewMatrix = mat4.create();
        mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -6.0]); // 将立方体移向屏幕内
        mat4.rotate(modelViewMatrix, modelViewMatrix, rotation[0], [1, 0, 0]); // 绕x轴旋转
        mat4.rotate(modelViewMatrix, modelViewMatrix, rotation[1], [0, 1, 0]); // 绕y轴旋转

        // 将模型视图矩阵传递给着色器
        gl.uniformMatrix4fv(
          programInfo.uniformLocations.modelViewMatrix,
          false,
          modelViewMatrix
        );

        // 创建并设置投影矩阵
        const projectionMatrix = mat4.create();
        mat4.perspective(
          projectionMatrix,
          Math.PI / 4,
          gl.canvas.width / gl.canvas.height,
          0.1,
          100.0
        );
        gl.uniformMatrix4fv(
          programInfo.uniformLocations.projectionMatrix,
          false,
          projectionMatrix
        );

        // 绘制立方体
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0); // 36个顶点组成12个三角形
      }

      // 动画函数，用于逐帧更新旋转角度并重绘立方体
      function animate(gl, programInfo, buffers, rotation) {
        requestAnimationFrame((now) => {
          // 计算时间增量
          const deltaTime = (now - then) / 1000;
          then = now; // 更新全局时间

          // 更新旋转角度
          rotation[0] += deltaTime;
          rotation[1] += deltaTime;

          // 绘制场景
          drawScene(gl, programInfo, buffers, rotation);

          // 继续动画循环
          animate(gl, programInfo, buffers, rotation);
        });
      }

      // 主函数，初始化WebGL上下文、着色器和缓冲区，并启动动画
      function main() {
        const canvas = document.querySelector("#glCanvas"); // 获取canvas元素
        const gl = canvas.getContext("webgl"); // 获取WebGL上下文

        // 检查WebGL是否可用
        if (!gl) {
          console.error(
            "Unable to initialize WebGL. Your browser or machine may not support it."
          );
          return;
        }

        const shaderProgram = initShaderProgram(
          gl,
          vertexShaderSource,
          fragmentShaderSource
        ); // 初始化着色器程序
        const programInfo = {
          program: shaderProgram,
          attribLocations: {
            vertexPosition: gl.getAttribLocation(
              shaderProgram,
              "aVertexPosition"
            ),
          },
          uniformLocations: {
            projectionMatrix: gl.getUniformLocation(
              shaderProgram,
              "uProjectionMatrix"
            ),
            modelViewMatrix: gl.getUniformLocation(
              shaderProgram,
              "uModelViewMatrix"
            ),
          },
        };

        const buffers = initBuffers(gl); // 初始化缓冲区

        const rotation = [0, 0]; // 初始化旋转角度

        animate(gl, programInfo, buffers, rotation); // 启动动画
      }

      window.onload = main; // 在页面加载后启动main函数
    </script>
    <script src="https://cdn.jsdelivr.net/npm/gl-matrix@2.8.1/dist/gl-matrix-min.js"></script>
  </body>
</html>
