<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rotating Cube with WebGPU</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="gpuCanvas"></canvas>
    <script type="module">
      import { mat4 } from 'https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/esm/index.js';
      // 基本环境检测
      if (!('gpu' in navigator)) {
        document.body.innerHTML = '此浏览器不支持 WebGPU，请使用最新版 Chrome/Edge。';
      }

      // WGSL 着色器
      const shaderCode = `
        struct Uniforms {
          mvp : mat4x4<f32>
        };
        @group(0) @binding(0) var<uniform> uniforms : Uniforms;

        struct VSOut {
          @builtin(position) position : vec4<f32>
        };

        @vertex
        fn vs_main(@location(0) position : vec3<f32>) -> VSOut {
          var out : VSOut;
          out.position = uniforms.mvp * vec4<f32>(position, 1.0);
          return out;
        }

        @fragment
        fn fs_main() -> @location(0) vec4<f32> {
          return vec4<f32>(0.0, 1.0, 0.0, 1.0);
        }
      `;

      async function main() {
        const canvas = document.getElementById('gpuCanvas');
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          document.body.innerHTML = '无法获取 WebGPU 适配器。';
          return;
        }
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');

        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        /// 处理画布尺寸变化和像素密度适配，确保 WebGPU 渲染在不同设备和窗口大小下都能正确显示
        function resizeCanvas() {
          const dpr = window.devicePixelRatio || 1;
          const width = Math.floor(canvas.clientWidth * dpr);
          const height = Math.floor(canvas.clientHeight * dpr);
          if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
            context.configure({
              device,
              format: presentationFormat,
              alphaMode: 'opaque'
            });
            createDepthTexture(width, height);
          }
        }
        // 初始配置（需先有尺寸）
        context.configure({ device, format: presentationFormat, alphaMode: 'opaque' });

        let depthTexture = null;
        function createDepthTexture(width, height) {
          depthTexture = device.createTexture({
            size: { width, height, depthOrArrayLayers: 1 },
            format: 'depth24plus',
            usage: GPUTextureUsage.RENDER_ATTACHMENT
          });
        }

        // 顶点与索引（与 WebGL 版本一致）
        const vertices = new Float32Array([
          // Front face
          -1.0, -1.0,  1.0,  1.0, -1.0,  1.0,  1.0,  1.0,  1.0,  -1.0,  1.0,  1.0,
          // Back face
          -1.0, -1.0, -1.0, -1.0,  1.0, -1.0,  1.0,  1.0, -1.0,   1.0, -1.0, -1.0,
          // Top face
          -1.0,  1.0, -1.0, -1.0,  1.0,  1.0,  1.0,  1.0,  1.0,   1.0,  1.0, -1.0,
          // Bottom face
          -1.0, -1.0, -1.0,  1.0, -1.0, -1.0,  1.0, -1.0,  1.0,  -1.0, -1.0,  1.0,
          // Right face
           1.0, -1.0, -1.0,  1.0,  1.0, -1.0,  1.0,  1.0,  1.0,   1.0, -1.0,  1.0,
          // Left face
          -1.0, -1.0, -1.0, -1.0, -1.0,  1.0, -1.0,  1.0,  1.0,  -1.0,  1.0, -1.0,
        ]);

        const indices = new Uint16Array([
           0,  1,  2,   0,  2,  3,
           4,  5,  6,   4,  6,  7,
           8,  9, 10,   8, 10, 11,
          12, 13, 14,  12, 14, 15,
          16, 17, 18,  16, 18, 19,
          20, 21, 22,  20, 22, 23,
        ]);

        const vertexBuffer = device.createBuffer({
          size: vertices.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(vertexBuffer, 0, vertices);

        const indexBuffer = device.createBuffer({
          size: indices.byteLength,
          usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(indexBuffer, 0, indices);

        // Uniform: MVP 矩阵
        const uniformBufferSize = 16 * 4; // 4x4 矩阵，float32
        const uniformBuffer = device.createBuffer({
          size: uniformBufferSize,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });

        const bindGroupLayout = device.createBindGroupLayout({
          entries: [
            { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: 'uniform' } }
          ]
        });

        const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });

        // 着色器
        const shaderModule = device.createShaderModule({ code: shaderCode });

        // 提前构建渲染管线（一次性）
        const pipeline = device.createRenderPipeline({
          layout: pipelineLayout,
          vertex: {
            module: shaderModule,
            entryPoint: 'vs_main',
            buffers: [
              {
                arrayStride: 3 * 4,
                attributes: [
                  { shaderLocation: 0, offset: 0, format: 'float32x3' }
                ]
              }
            ]
          },
          fragment: {
            module: shaderModule,
            entryPoint: 'fs_main',
            targets: [{ format: presentationFormat }]
          },
          primitive: { topology: 'triangle-list', cullMode: 'back' },
          depthStencil: { format: 'depth24plus', depthWriteEnabled: true, depthCompare: 'less' }
        });

        const bindGroup = device.createBindGroup({
          layout: bindGroupLayout,
          entries: [
            { binding: 0, resource: { buffer: uniformBuffer } }
          ]
        });

        // 矩阵准备
        const modelViewMatrix = mat4.create();
        const projectionMatrix = mat4.create();
        const mvpMatrix = mat4.create();
        let then = 0;

        // 每帧只需记录命令并一次性提交
        function frame(now) {
          const dt = then ? (now - then) / 1000 : 0;
          then = now;

          resizeCanvas();
          const width = canvas.width;
          const height = canvas.height;

          // 更新矩阵
          mat4.identity(modelViewMatrix);
          mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -6]);
          const rx = now * 0.001; // 旋转速度
          const ry = now * 0.001;
          mat4.rotateX(modelViewMatrix, modelViewMatrix, rx);
          mat4.rotateY(modelViewMatrix, modelViewMatrix, ry);

          mat4.perspective(
            projectionMatrix,
            Math.PI / 4,
            width / Math.max(1, height),
            0.1,
            100
          );
          mat4.multiply(mvpMatrix, projectionMatrix, modelViewMatrix);
          device.queue.writeBuffer(uniformBuffer, 0, mvpMatrix);

          // 渲染一次
          const colorView = context.getCurrentTexture().createView();
          const depthView = depthTexture.createView();

          const encoder = device.createCommandEncoder();
          const pass = encoder.beginRenderPass({
            /// 纹理
            colorAttachments: [
              {
                view: colorView,
                clearValue: { r: 0, g: 0, b: 0, a: 1 },
                loadOp: 'clear',
                storeOp: 'store'
              }
            ],
            depthStencilAttachment: {
              view: depthView,
              depthClearValue: 1.0,
              depthLoadOp: 'clear',
              depthStoreOp: 'store'
            }
          });

          // 批量设置所有状态
          pass.setPipeline(pipeline);
          pass.setVertexBuffer(0, vertexBuffer);
          pass.setIndexBuffer(indexBuffer, 'uint16');
          pass.setBindGroup(0, bindGroup);
          pass.drawIndexed(36, 1, 0, 0, 0);
          pass.end();

          // 一次性提交所有命令
          device.queue.submit([encoder.finish()]);
          requestAnimationFrame(frame);
        }

        // 初始化一次深度纹理并开始动画
        resizeCanvas();
        requestAnimationFrame(frame);
      }

      main();
    </script>
  </body>
</html>


